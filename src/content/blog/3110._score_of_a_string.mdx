---
blogid: "05fe91bd"
title: "3110. Score Of A String"
description: "Master string traversal and ASCII manipulation by calculating the score of a string - a perfect introduction to linear algorithms."
date: "2025-11-30"
modifiedDate: "2025-11-30"
tags: ["algorithm", "data-structures", "string-manipulation", "ascii", "leetcode-easy", "linear-scan"]
thumbnailText: "Calculate String Score"
words: ["ASCII", "absolute", "difference", "adjacent", "traversal", "linear", "complexity", "python", "java", "cpp", "implementation", "volatility", "signal-processing", "optimization", "pairwise", "iteration", "char-code", "ordinal", "loop", "accumulator", "delta", "encoding"]
cover: ""
author: "Agentic AI"
authorUsername: "Agentic AI"
authorLinkedIn: "https://www.linkedin.com/in/agentic-ai/"
modelConfig:
  visualization: "anthropic/claude-4.5-sonnet"
  contextGathering:
    - "openai/gpt-5.1"
    - "anthropic/claude-4-sonnet"
    - "google/gemini-3-pro-preview"
  workflow:
    synthesis: "google/gemini-3-pro-preview"
    correction: "google/gemini-3-pro-preview"
    humanization: "google/gemini-3-pro-preview"
---

import { injectCode } from "@src/utils/blog-utils";
import StringScoreBasic from "@components/examples/3110.-score-of-a-string/StringScoreBasic";
import StringScoreComparison from "@components/examples/3110.-score-of-a-string/StringScoreComparison";
import StringScoreOptimizer from "@components/examples/3110.-score-of-a-string/StringScoreOptimizer";

# 3110. Score of a String: A Gateway to ASCII Manipulation

We usually think of strings as text—words, sentences, maybe a bit of JSON. But deep down, your computer just sees a sequence of numbers. LeetCode problem **3110. Score of a String** is a great little exercise that peels back that text layer to show you the raw numerical machinery underneath.

The problem asks us to calculate the "score" of a string. In plain English, we need to sum up the **absolute differences** between the ASCII values of side-by-side characters. It's categorized as an Easy problem, and honestly, it is. But it's also a fantastic way to get comfortable with data encoding and linear traversal without getting bogged down in complex logic.

## Real-World Analogy: The Hiking Trail

If the math sounds dry, let's swap the "score" for something tangible: a hiking trail.

<Notation type="box" color="blue" padding={10} strokeWidth={2}>
**Analogy**: Imagine each character's ASCII value is the **elevation** (height) of a checkpoint on a mountain. The "Score" is simply the **total vertical effort** of your hike. It doesn't matter if you're climbing up a steep hill or scrambling down a ravine (absolute difference); every meter of elevation change burns energy and adds to your total effort.
</Notation>

## Interactive Visualization: Calculating the Score

It's always easier to see this in action. Let's look at what happens with a simple string like "hello." Watch how we grab pairs of neighbors and calculate the gap between them.

<StringScoreBasic client:load />

## Core Concepts

To knock this problem out, you really only need three tools in your belt:

1.  **ASCII Values**: Computers store characters as integers. 'a' isn't just a letter; it's the number 97. 'b' is 98, and 'z' is 122.
    *   **Python**: Use `ord('a')`
    *   **Java**: Cast it like `(int) 'a'`
    *   **C++**: Just treat `'a'` like a number (it does this implicitly)
2.  **Adjacent Pairs**: We need to look at `s[i]` and its neighbor `s[i+1]`. If you have a string of length $N$, you're going to have exactly $N-1$ comparisons.
3.  **Absolute Difference**: This is just the distance between two numbers. It doesn't care about direction. The distance from 10 to 5 is 5, and from 5 to 10 is also 5.

<Notation type="highlight" color="rgba(255, 235, 59, 0.4)" padding={5}>
**Mathematical Definition**: Score = $\sum_{i=0}^{n-2} | \text{ASCII}(s[i]) - \text{ASCII}(s[i+1]) |$
</Notation>

## Step-by-Step Walkthrough

Let's walk through the logic manually with `s = "hello"` so there are no surprises when we write the code.

1.  **Initialize**: Start with `score = 0`.
2.  **Pair 1 ('h', 'e')**:
    *   'h' is 104, 'e' is 101.
    *   Difference = $|104 - 101| = 3$.
    *   Current Score = 3.
3.  **Pair 2 ('e', 'l')**:
    *   'e' is 101, 'l' is 108.
    *   Difference = $|101 - 108| = 7$.
    *   Current Score = 3 + 7 = 10.
4.  **Pair 3 ('l', 'l')**:
    *   Both are 108.
    *   Difference is 0 (flat ground).
    *   Current Score = 10 + 0 = 10.
5.  **Pair 4 ('l', 'o')**:
    *   'l' is 108, 'o' is 111.
    *   Difference = $|108 - 111| = 3$.
    *   Final Score = 10 + 3 = 13.

**Final Score**: 13

## Implementation

The strategy here is a **Linear Scan** ($O(N)$). We just walk down the string once, checking each character against the next one in line.

<CodeTabs
    tabLabels={["Java", "C++", "Python"]}
    tabs={{
        "java": injectCode(`class Solution {
    public int scoreOfString(String s) {
        int score = 0;
        
        // Iterate from 0 up to the second-to-last character
        // We stop at length() - 1 to avoid IndexOutOfBounds when accessing i+1
        for (int i = 0; i < s.length() - 1; i++) {
            // s.charAt returns a char, which is implicitly promoted to int for subtraction
            // Math.abs handles the absolute value
            score += Math.abs(s.charAt(i) - s.charAt(i + 1));
        }
        
        return score;
    }
}`),
        "cpp": injectCode(`class Solution {
public:
    int scoreOfString(string s) {
        int score = 0;
        
        // Iterate through the string
        // Ensure we don't go out of bounds (i + 1)
        for (int i = 0; i < s.length() - 1; ++i) {
            // std::abs calculates absolute difference
            // char types in C++ can be subtracted directly
            score += std::abs(s[i] - s[i+1]);
        }
        
        return score;
    }
};`),
        "python": injectCode(`class Solution:
    def scoreOfString(self, s: str) -> int:
        score = 0
        
        # Iterate from index 0 to len(s) - 2
        for i in range(len(s) - 1):
            # ord() converts character to its ASCII integer value
            val1 = ord(s[i])
            val2 = ord(s[i+1])
            
            # Add absolute difference to total score
            score += abs(val1 - val2)
            
        return score

    # Pythonic One-Liner Alternative (for interview discussions):
    # return sum(abs(ord(a) - ord(b)) for a, b in zip(s, s[1:]))`)
    }}
/>

## Visualizing the Comparison

Sometimes it helps to see the data flow. The visualization below tracks the raw ASCII values alongside the accumulating score, so you can see exactly how the volatility of the characters impacts the final number.

<StringScoreComparison client:load />

## Complexity Analysis

We can't skip the efficiency check (interviewers love this part).

<Notation type="underline" color="purple" strokeWidth={2} padding={5}>
**Time Complexity**: $O(N)$ - We visit every character exactly once.
</Notation>

*   **The Gist**: The loop runs roughly $N$ times. Inside the loop, we're just doing basic math (subtraction, addition), which is super fast.

<Notation type="underline" color="purple" strokeWidth={2} padding={5}>
**Space Complexity**: $O(1)$ - Constant extra space.
</Notation>

*   **The Gist**: We aren't creating new arrays or massive data structures. We just need a variable for the `score` and one for the iterator `i`. It doesn't matter if the string is 5 characters or 5 million; the memory usage stays the same.

## Optimization and Variations

While the standard loop is the "correct" answer, different languages have their own flavor. The visualization below highlights how we can optimize the *perception* of the data flow, even if the underlying complexity stays linear.

<StringScoreOptimizer client:load />

### Pythonic Approach: `pairwise`
If you're using Python 3.10+, you can look extra fancy by using `itertools.pairwise`. It handles the "neighbor" logic for you:

```python
from itertools import pairwise

class Solution:
    def scoreOfString(self, s: str) -> int:
        return sum(abs(ord(a) - ord(b)) for a, b in pairwise(s))
```

## Common Pitfalls

Here is where most people trip up on this problem.

<Notation type="circle" color="red" padding={12} strokeWidth={2}>
⚠️ **The Classic Trap**: Off-by-One Errors (IndexOutOfBounds)
</Notation>

*   **The Mistake**: Writing a loop like `for i in range(len(s))` and then trying to access `s[i+1]`.
*   **The Fix**: You have to stop one step early (`len(s) - 1`). Why? Because the very last character in the string has no neighbor to its right. If you try to shake hands with a ghost, your program crashes.

**Other things to watch out for:**
1.  **Forgetting Absolute Value**: `('a' - 'z')` gives you `-25`. If you forget `abs()`, you'll end up subtracting from your score instead of adding the distance.
2.  **Edge Cases**: The constraints usually say the string will have at least 2 characters. But in a real interview, you should always ask: "What happens if the string is empty or has just one letter?" (Usually, the score would be 0).

## Practical Applications

So, why should you care about this besides passing a coding test?

1.  **Delta Encoding**: This is actually how a lot of data compression works. Instead of storing big raw numbers like `[100, 102, 105]`, we just store the changes: `[100, +2, +3]`. Smaller numbers take up less space.
2.  **Signal Processing**: Measuring the sum of absolute differences is a quick way to check how "bumpy" or volatile a signal is. A low score means a smooth line; a high score means lots of noise.
3.  **Bioinformatics**: When comparing DNA sequences, we often convert nucleotides to numbers to figure out how "far apart" two genetic sequences are.

## Conclusion

"Score of a String" isn't the hardest problem you'll ever solve, but it's a solid sanity check for your understanding of loops and character encoding. If you can master this, you're setting yourself up for success with harder string algorithms like Edit Distance later on.

Just remember the hiking analogy: whether the trail goes up or down, your legs still feel the burn. In this algorithm, every step counts.